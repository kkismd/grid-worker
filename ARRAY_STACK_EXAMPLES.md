# 配列とスタック機能の使用例

WorkerScriptに配列とスタック機能が追加されました。このドキュメントでは、その使用方法と実践的な例を紹介します。

## 概要

- **配列**: `[address]` 記法で65536要素のメモリ空間にアクセス
- **スタック**: `[-1]` リテラルでLIFO（後入れ先出し）スタック操作
- **共有メモリ**: 配列とスタックは同じInt16Arrayメモリ空間を使用
- **スタック方向**: アドレス65535から下向きに伸びる

## 基本的な配列操作

### 配列への書き込みと読み取り

```workerscript
: 配列の基本操作
[0]=100          : インデックス0に100を書き込み
A=[0]            : インデックス0から読み取り、変数Aに代入
?=A              : 100が出力される
```

### 変数をインデックスとして使用

```workerscript
: 動的なインデックスアクセス
I=10
[I]=42           : [10]=42と同じ
B=[I]            : B=42
?=B
```

### 式をインデックスとして使用

```workerscript
: 計算されたインデックス
BASE=1000
OFFSET=5
[BASE+OFFSET]=99  : [1005]=99
C=[BASE+OFFSET]   : C=99
?=C
```

## 配列の初期化

### 複数の値を一度に書き込み

```workerscript
: 配列初期化（カンマ区切り）
[1000]=10,20,30,40,50

: 読み取り
A=[1000]  : A=10
B=[1001]  : B=20
C=[1002]  : C=30
D=[1003]  : D=40
E=[1004]  : E=50
```

### 式を使った初期化

```workerscript
: 変数や式で初期化
X=100
Y=200
[2000]=X,Y,X+Y,X*2

A=[2000]  : A=100
B=[2001]  : B=200
C=[2002]  : C=300
D=[2003]  : D=200
```

## ループでの配列使用

### 配列への連続書き込み

```workerscript
: 0〜9の二乗を配列に格納
@=I,0,9
    [I]=I*I
#=@

: 確認
?=[5]     : 25が出力される
?=[9]     : 81が出力される
```

### 配列を使った累積処理

```workerscript
: 配列の合計を計算
[100]=10,20,30,40,50

SUM=0
@=I,100,104
    SUM=SUM+[I]
#=@
?=SUM     : 150が出力される
```

### 配列のコピー

```workerscript
: 配列を別の領域にコピー
[1000]=1,2,3,4,5

@=I,0,4
    SRC=1000+I
    DST=2000+I
    [DST]=[SRC]
#=@

: 確認
?=[2000]  : 1
?=[2004]  : 5
```

## スタック操作の基本

### 基本的なpushとpop

```workerscript
: スタックにpush
[-1]=10
[-1]=20
[-1]=30

: スタックからpop（LIFO順）
A=[-1]    : A=30（最後に入れた値）
B=[-1]    : B=20
C=[-1]    : C=10（最初に入れた値）
```

### スタックを使った一時保存

```workerscript
: 変数の値を一時保存
A=100
B=200

[-1]=A    : Aをpush
[-1]=B    : Bをpush

: AとBを使った別の計算
A=5
B=3
C=A+B     : C=8

: 元の値を復元
B=[-1]    : B=200に戻る
A=[-1]    : A=100に戻る
```

## 実践的な例

### 例1: フィボナッチ数列を配列に生成

```workerscript
: フィボナッチ数列を10個生成
[0]=0
[1]=1

@=I,2,9
    PREV1=[I-1]
    PREV2=[I-2]
    [I]=PREV1+PREV2
#=@

: 結果を表示
@=I,0,9
    ?=[I] /
#=@
: 出力: 0 1 1 2 3 5 8 13 21 34
```

### 例2: スタックを使った逆順出力

```workerscript
: 1〜5をスタックにpush
@=I,1,5
    [-1]=I
#=@

: popして表示（5,4,3,2,1の順）
@=I,1,5
    ?=[-1] /
#=@
: 出力: 5 4 3 2 1
```

### 例3: 配列のバブルソート（簡易版）

```workerscript
: ソート対象の配列を初期化
[0]=64,34,25,12,22,11,90

N=7  : 要素数

: バブルソート
@=I,0,N-2
    @=J,0,N-I-2
        A=[J]
        B=[J+1]
        ;=A>B
            : 交換（スタックを使用）
            [-1]=A
            [J]=[J+1]
            [J+1]=[-1]
    #=@
#=@

: ソート結果を表示
@=I,0,N-1
    ?=[I] /
#=@
: 出力: 11 12 22 25 34 64 90
```

### 例4: スタックを使った式の評価（逆ポーランド記法風）

```workerscript
: スタック計算の例
: (5 + 3) * (10 - 2) を計算

: 5 + 3を計算
[-1]=5
[-1]=3
SUM=[-1]+[-1]
[-1]=SUM      : 8をpush

: 10 - 2を計算
[-1]=10
[-1]=2
B=[-1]
A=[-1]
DIFF=A-B
[-1]=DIFF     : 8をpush

: 掛け算
RESULT=[-1]*[-1]
?=RESULT      : 64が出力される
```

### 例5: 配列を使ったヒストグラム

```workerscript
: 0〜9の範囲のランダムな値の出現回数を数える

: ヒストグラムを0で初期化
@=I,0,9
    [I]=0
#=@

: ランダム値を生成してカウント（簡易版）
@=I,0,99
    VAL=?%10      : 0〜9の値を生成（簡易的な例）
    [VAL]=[VAL]+1
#=@

: 結果を表示
@=I,0,9
    ?=I ?"=" ?=[I] /
#=@
```

### 例6: スタックを使った再帰的計算の模倣

```workerscript
: 階乗計算（5!を計算）
: スタックに5,4,3,2,1をpush

@=I,5,1,-1
    [-1]=I
#=@

: 全てpopして掛け算
RESULT=1
@=I,1,5
    RESULT=RESULT*[-1]
#=@
?=RESULT      : 120が出力される（5! = 5*4*3*2*1）
```

## ネストした配列アクセス

### 間接参照

```workerscript
: 配列を使った間接参照
[0]=100       : インデックステーブル
[100]=42      : 実際のデータ

: [[0]]は[100]と同じ
VALUE=[[0]]   : VALUE=42
?=VALUE
```

### ポインタ風の使用

```workerscript
: 配列をポインタのように使う
PTR=1000
[PTR]=10,20,30

: ポインタを進めながらアクセス
A=[PTR]       : A=10
PTR=PTR+1
B=[PTR]       : B=20
PTR=PTR+1
C=[PTR]       : C=30
```

## メモリ空間の理解

### アドレス範囲

- **配列**: 0〜65535 (0x0000〜0xFFFF)
- **スタック開始**: 65535 (0xFFFF)から下向き
- **インデックスの正規化**: `index & 0xFFFF`で自動的に範囲内に収まる

```workerscript
: 65536は0と同じアドレス
[65536]=99
?=[0]         : 99が出力される

: 負のインデックスは正規化される
: -1 & 0xFFFF = 65535
[-2]=77       : これは変数アクセス（リテラル[-1]のみスタック）
?=[65534]     : 77が出力される可能性（実装依存）
```

## 注意事項

### リテラル[-1]のみスタック操作

```workerscript
: これはスタック操作
[-1]=100
A=[-1]

: これは配列アクセス（I=-1の場合）
I=-1
[I]=100       : メモリアドレス65535への書き込み
B=[I]         : メモリアドレス65535からの読み取り
```

### VTL仕様に準拠

- **オーバーフロー/アンダーフローチェックなし**: スタックポインタは単に0xFFFFでマスク
- **未初期化メモリ**: 読み取ると0を返す
- **型**: 全て16bit符号付き整数 (Int16Array)

## パフォーマンスのヒント

1. **配列の局所性**: 近いアドレスを連続してアクセスすると効率的
2. **スタック深さ**: 深いネストは避ける（可読性のため）
3. **インデックス計算**: 複雑な式は変数に格納してから使う

```workerscript
: 良い例
BASE=1000
OFFSET=I*10+J
[BASE+OFFSET]=VALUE

: 避けたい例
[1000+I*10+J]=VALUE   : 式が複雑で読みにくい
```

## まとめ

配列とスタックを活用することで、WorkerScriptでより複雑なデータ構造とアルゴリズムを実装できます。

- **配列**: データの永続的な保存、テーブル、バッファ
- **スタック**: 一時的なデータ保存、計算の中間結果、LIFO構造

両機能を組み合わせることで、強力なプログラムを作成できます。
