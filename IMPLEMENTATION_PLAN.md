# WorkerScriptインタプリタ実装計画 (TDDサイクル)

**コンテキスト回復プロンプト:**

もし作業中にコンテキストを見失った場合は、以下のプロンプトを使用してください。

```
これまでの作業のコンテキストを回復してください。現在のプロジェクトの状況、直近の議論、および次に着手すべきTDDサイクルについて教えてください。
```

このドキュメントは、WorkerScriptインタプリタの実装をTDD (Test-Driven Development) のRed-Green-Refactorサイクルで進めるための計画をアウトライン化したものです。

## 全体的なアプローチ

インタプリタの実装は、以下の主要なフェーズに分けて進めます。

1.  **字句解析 (Tokenization):** 入力スクリプトを意味のある最小単位（トークン）に分割します。
2.  **構文解析 (Parsing) & AST構築:** トークンのリストからプログラムの構造を表す抽象構文木 (AST) を構築します。
3.  **実行 (Interpretation):** 構築されたASTをトラバースし、WorkerScriptのセマンティクスに従ってステートメントを実行します。

各フェーズは、さらに具体的な目標を持つTDDサイクルに分割されます。

## フェーズ1: 字句解析 (Tokenization)

**目標:** 入力スクリプトをトークン（単語、記号など）のリストに分割する。

### TDDサイクル 1.1: 空のスクリプト、コメント行、単純な数値リテラル、変数名のトークン化

*   **Red (テスト):**
    *   空のスクリプトが空のトークンリストを返すことを期待するテスト。
    *   コメント行 (`: This is a comment`) がコメントトークンとして扱われることを期待するテスト。
    *   単純な数値リテラル (`123`) が数値トークンとして扱われることを期待するテスト。
    *   変数名 (`A`, `Z`) が変数トークンとして扱われることを期待するテスト。
    *   `A=10` のような単純な代入文で、`A`, `=`, `10` が正しくトークン化されることを期待するテスト。
*   **Green (実装):**
    *   `WorkerInterpreter` クラス内に字句解析の初期ロジックを実装し、上記のテストがパスするようにする。
    *   `loadScript` メソッド内でこの字句解析を呼び出す。
*   **Refactor (リファクタリング):**
    *   トークンを表すデータ構造（例: `Token` インターフェース/クラス）を定義し、コードの整理、命名規則の改善を行う。

### TDDサイクル 1.2: 演算子、文字列リテラル、ラベルのトークン化

*   **Red (テスト):**
    *   算術演算子 (`+`, `-`, `*`, `/`)、比較演算子 (`=`, `>`, `<`, `>=`, `<=`, `<>`)、論理演算子 (`&`, `|`, `!`) が正しくトークン化されることを期待するテスト。
    *   文字列リテラル (`"Hello World"`) が文字列トークンとして扱われることを期待するテスト。
    *   ラベル定義 (`^MY_LABEL`) がラベルトークンとして扱われることを期待するテスト。
*   **Green (実装):**
    *   字句解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   字句解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 1.3: 複数のステートメントを含む行のトークン化

*   **Red (テスト):**
    *   `A=10 B=20` のようにスペースで区切られた複数のステートメントが正しくトークン化されることを期待するテスト。
    *   `;=A>100 ?=100 #=^END` のような `IF` ステートメント内の複数のアクションが正しくトークン化されることを期待するテスト。
*   **Green (実装):**
    *   字句解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   字句解析器のコードを整理し、可読性と保守性を向上させる。

## フェーズ2: 構文解析 (Parsing) & AST構築

**目標:** トークンのリストから抽象構文木 (AST) を構築する。

### TDDサイクル 2.1: 単純な代入ステートメントの解析

*   **Red (テスト):**
    *   `A=10` のような代入ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   `WorkerInterpreter` クラス内に構文解析の初期ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   ASTノードを表すデータ構造（例: `ASTNode`, `AssignmentStatement` インターフェース/クラス）を定義し、コードの整理を行う。

### TDDサイクル 2.2: 出力ステートメント (`?=`, `/`) の解析

*   **Red (テスト):**
    *   `?=10`, `?="Hello"`, `/` のような出力ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.3: 算術演算を含む式の解析

*   **Red (テスト):**
    *   `C=A+B`, `D=10*5-2` のような算術演算を含む式が正しいASTノードに解析されることを期待するテスト。
    *   括弧を含む式 (`E=(A+B)*C`) が正しく解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.4: 比較演算、論理演算を含む式の解析

*   **Red (テスト):**
    *   `F=A>B`, `G=X=Y`, `H=A&B|C` のような比較演算、論理演算を含む式が正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.5: `IF` ステートメントの解析

*   **Red (テスト):**
    *   `;=A>100 ?=100 #=^END` のような `IF` ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.6: `GOTO`, `GOSUB`, `RETURN` ステートメントの解析

*   **Red (テスト):**
    *   `#=^START_LOOP`, `!=^MY_SUB`, `]` のような制御フロー関連ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.7: `FOR` ループの初期化ステートメントの解析

*   **Red (テスト):**
    *   `I=1,100`, `J=10,1,-1` のような `FOR` ループ初期化ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.8: `NEXT` ステートメントの解析

*   **Red (テスト):**
    *   `@=I` のような `NEXT` ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.9: `PEEK`, `POKE` ステートメントの解析

*   **Red (テスト):**
    *   `A = *`, `* = C` のような `PEEK`, `POKE` ステートメントが正しいASTノードに解析されることを期待するテスト。
*   **Green (実装):**
    *   構文解析ロジックを拡張し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   構文解析器のコードを整理し、可読性と保守性を向上させる。

### TDDサイクル 2.10: ラベル定義の解析と重複チェック

*   **Red (テスト):**
    *   `^MY_LABEL` のようなラベル定義が正しく認識され、`labels` マップに登録されることを期待するテスト。
    *   重複するラベル定義が構文エラーをスローすることを期待するテスト。
*   **Green (実装):**
    *   `loadScript` メソッド内のラベル解析ロジックを強化し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   `loadScript` メソッドのコードを整理し、エラーハンドリングを改善する。

## フェーズ3: 実行 (Interpretation)

**目標:** 構築されたASTをトラバースし、ステートメントを実行する。

### TDDサイクル 3.1: 変数代入の実行

*   **Red (テスト):**
    *   `A=10` のような代入ステートメントが `InterpreterState` の `variables` を正しく更新することを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に代入ステートメントの実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   変数アクセスに関するヘルパーメソッド（例: `getVariableValue`, `setVariableValue`）を定義し、コードの整理を行う。

### TDDサイクル 3.2: 出力ステートメント (`?=`, `/`) の実行

*   **Red (テスト):**
    *   `?=10`, `?="Hello"`, `/` が `logFn` を正しく呼び出すことを期待するテスト。
    *   文字列連結がサポートされないことのテスト（エラーをスローするか、期待される挙動を確認）。
*   **Green (実装):**
    *   `executeStatement` メソッド内に出力ステートメントの実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.3: 算術演算、比較演算、論理演算の実行

*   **Red (テスト):**
    *   各種演算子を含む式が正しく評価され、結果が期待通りになることを期待するテスト。
    *   数値のオーバーフロー/アンダーフローがラップアラウンドすることを期待するテスト。
    *   ゼロ除算が実行時エラーをスローすることを期待するテスト。
*   **Green (実装):**
    *   式評価ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   式評価に関するヘルパーメソッド（例: `evaluateExpression`）を定義し、コードの整理を行う。

### TDDサイクル 3.4: `IF` ステートメントの条件評価と実行

*   **Red (テスト):**
    *   `IF` ステートメントの条件が真の場合に、後続のステートメントが実行されることを期待するテスト。
    *   条件が偽の場合に、後続のステートメントがスキップされることを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に `IF` ステートメントの実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.5: `GOTO` の実行

*   **Red (テスト):**
    *   `#=^LABEL` が `programCounter` を正しく更新し、指定されたラベルにジャンプすることを期待するテスト。
    *   未定義ラベルへの `GOTO` がエラーをスローすることを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に `GOTO` の実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.6: `GOSUB` と `RETURN` の実行 (スタック管理を含む)

*   **Red (テスト):**
    *   `!=^SUB` が `callStack` にリターンアドレスをプッシュし、サブルーチンにジャンプすることを期待するテスト。
    *   `]` が `callStack` からリターンアドレスをポップし、元の位置に戻ることを期待するテスト。
    *   `GOSUB` のネストが最大深度を超えた場合にエラーをスローすることを期待するテスト。
    *   空のスタックからの `RETURN` がエラーをスローすることを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に `GOSUB` と `RETURN` の実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.7: `FOR` ループの初期化と `NEXT` の実行

*   **Red (テスト):**
    *   `I=1,5` のような `FOR` ループ初期化が `loopStack` を正しく設定することを期待するテスト。
    *   `@=I` がループ変数をインクリメントし、ループ条件に基づいてジャンプすることを期待するテスト。
    *   ループ変数の重複使用がエラーをスローすることを期待するテスト。
    *   ステップ値が `0` の場合にエラーをスローすることを期待するテスト。
    *   対応する `FOR` がない `NEXT` や、変数名が一致しない `NEXT` がエラーをスローすることを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に `FOR` と `NEXT` の実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.8: `PEEK` と `POKE` の実行

*   **Red (テスト):**
    *   `A = *` が `gridData` から値を読み出し、`X`, `Y` のラップアラウンドを考慮することを期待するテスト。
    *   `* = C` が `gridData` に値を書き込み、`X`, `Y` のラップアラウンドを考慮することを期待するテスト。
    *   `pokeFn` が正しく呼び出されることを期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内に `PEEK` と `POKE` の実行ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.9: プログラム停止 (`#=-1`) の実行

*   **Red (テスト):**
    *   `#=-1` が実行されたときに、Generatorが実行を終了すること (`done: true`) を期待するテスト。
*   **Green (実装):**
    *   `executeStatement` メソッド内にプログラム停止ロジックを実装し、上記のテストがパスするようにする。
*   **Refactor (リファクタリング):**
    *   コードの整理を行う。

### TDDサイクル 3.10: エラーハンドリングの総合テスト

*   **Red (テスト):**
    *   各種エラーケース（構文エラー、実行時エラー、未定義ラベルエラー）が期待通りにエラーをスローし、`logFn` でメッセージが出力されることを期待するテスト。
*   **Green (実装):**
    *   既存のエラーハンドリングロジックを検証し、必要に応じて修正する。
*   **Refactor (リファクタリング):**
    *   エラーメッセージのフォーマットや一貫性を改善する。
