# PEEK/POKE記号の競合分析と代替案

## 現在の実装: `*` (アスタリスク)

### 問題点の分析

#### 1. **乗算演算子との競合**

**構文レベルでの競合は発生しない（コンテキストで区別可能）:**
- `A=*` → PEEK（式の開始位置）
- `*=A` → POKE（代入の左辺）
- `A=B*C` → 乗算（二項演算子として使用）
- `A=*-2` → PEEK-2（単項PEEK後に減算）
- `A=2*3` → 乗算（数値リテラル後）

**パーサーの実装:**
```typescript
// parseExpression() でコンテキストに応じて判定
if (token.type === TokenType.ASTERISK) {
    // 式の開始位置またはプライマリ式としてのみPEEKと解釈
    return { type: 'PeekExpression', ... };
}

// parseBinaryExpression() で二項演算子として処理
if (operator === '*') {
    // 乗算演算子として解釈
}
```

#### 2. **視認性の問題**

**人間にとって混乱しやすいケース:**
```workerscript
A=*          : PEEK（メモリ読み取り）
B=2*3        : 乗算
C=*-2        : PEEKして2を引く（*がメモリ読み取り）
D=A*-2       : Aに-2を乗算（*が乗算演算子）
```

**特に問題となるパターン:**
```workerscript
: これは何を意味するか？
X=A*B        : A×B（明確）
X=**2        : ???（*をPEEKして2を乗算？構文エラー？）
X=*+*        : 2つのPEEKを加算（分かりにくい）
*=*+1        : PEEKした値に1を加えてPOKE（非常に分かりにくい）
```

#### 3. **VTL2との互換性**

VTL2では:
- `*` はメモリサイズを表すシステム変数
- 配列アクセスは `:index)` 構文を使用
- 乗算も `*` を使用

WorkerScriptでは:
- `*` をPEEK/POKEのメモリアクセスに転用
- 乗算も `*` を使用（VTL2と同じ）
- **意味的な競合が発生**

## 使用中の記号一覧

### 演算子
- `+` : 加算
- `-` : 減算、単項マイナス
- `*` : 乗算、**PEEK/POKE** ← 競合
- `/` : 除算、改行ステートメント
- `=` : 代入、等価比較
- `>` : より大きい
- `<` : より小さい
- `>=` : 以上
- `<=` : 以下
- `<>` : 等しくない
- `&` : 論理AND
- `|` : 論理OR
- `!` : 論理NOT、GOSUBの記号

### 制御・特殊記号
- `?` : 出力ステートメント
- `;` : IFステートメント
- `#` : GOTOステートメント
- `]` : RETURNステートメント
- `@` : NEXTステートメント
- `,` : FORループの区切り
- `(` `)` : 式のグループ化
- `^` : ラベル定義
- `:` : コメント

## 未使用の記号候補

### ASCII記号（一般的なキーボードで入力可能）

#### グループ1: 括弧類
- `[` `]` : 角括弧（`]`はRETURNで使用中）
- `{` `}` : 波括弧 ✓ **候補**

#### グループ2: 引用符・アクセント
- `` ` `` : バッククォート ✓ **候補**
- `'` : シングルクォート（文字列で使用される可能性）
- `"` : ダブルクォート（文字列リテラルで使用中）

#### グループ3: 数学・通貨記号
- `%` : パーセント ✓ **候補**（剰余演算子として将来使用の可能性）
- `$` : ドル記号 ✓ **候補**

#### グループ4: その他の記号
- `~` : チルダ ✓ **候補**
- `` ` `` : バックスラッシュ（エスケープで使用の可能性）
- `_` : アンダースコア（識別子で使用）

## 代替案の評価

### 案1: `@` を使用
```workerscript
A=@          : PEEK
@=A          : POKE
```
**問題:** `@` は既にNEXTステートメント（`@=I`）で使用中 ❌

### 案2: `$` を使用
```workerscript
A=$          : PEEK
$=A          : POKE
```
**利点:**
- ✓ 未使用の記号
- ✓ VTL2では単一文字入出力で使用（類似性あり）
- ✓ 乗算との競合なし
- ✓ 視認性が高い

**欠点:**
- ⚠ 一部の言語で変数のプレフィックスとして使用（混乱の可能性）
- ⚠ 通貨記号としての連想が強い

**評価:** ★★★★☆ 有力候補

### 案3: `%` を使用
```workerscript
A=%          : PEEK
%=A          : POKE
```
**利点:**
- ✓ 未使用の記号
- ✓ VTL2では除算の余りを表すシステム変数（計算関連の連想）
- ✓ 乗算との競合なし

**欠点:**
- ⚠ 剰余演算子として将来追加される可能性
- ⚠ メモリアクセスとの意味的関連性が薄い

**評価:** ★★★☆☆

### 案4: `` ` `` (バッククォート) を使用
```workerscript
A=`          : PEEK
`=A          : POKE
```
**利点:**
- ✓ 未使用の記号
- ✓ 乗算との競合なし
- ✓ 一般的な言語で変数参照やコマンド実行に使用（間接アクセスの連想）

**欠点:**
- ⚠ キーボードで入力しにくい
- ⚠ 視認性が低い
- ⚠ マークダウンなどでエスケープが必要

**評価:** ★★☆☆☆

### 案5: `~` を使用
```workerscript
A=~          : PEEK
~=A          : POKE
```
**利点:**
- ✓ 未使用の記号
- ✓ 乗算との競合なし
- ✓ ビット反転演算子として使われることが多い（低レベル操作の連想）

**欠点:**
- ⚠ キーボードで入力しにくい（Shift押しながら）
- ⚠ メモリアクセスとの意味的関連性が弱い

**評価:** ★★☆☆☆

### 案6: `{` `}` を使用（ペア記号）
```workerscript
A={0}        : PEEK(0) 的な表現
{0}=A        : POKE(0, A) 的な表現
```
**問題:** 括弧内に式が必要になり、構文が複雑化 ❌

### 案7: 現状維持 `*` を使用
```workerscript
A=*          : PEEK
*=A          : POKE
```
**利点:**
- ✓ 既に実装済み（変更コスト0）
- ✓ VTL2でメモリサイズを表す変数として使用（メモリ関連の連想）
- ✓ シンプルで短い
- ✓ パーサーでコンテキストにより正確に区別可能

**欠点:**
- ⚠ 人間にとって視認性が低い（特に`*=*+1`のようなケース）
- ⚠ 乗算との意味的な競合
- ⚠ 初心者には混乱を招く可能性

**評価:** ★★★☆☆

## 推奨案

### 第1候補: `$` を使用

```workerscript
: メモリアクセスの例
A=$          : gridData[<計算されたインデックス>] を読み取り
$=A          : gridData[<計算されたインデックス>] に書き込み

: 実用例
I=0
$=1          : gridData[0] = 1
I=I+1
A=$          : A = gridData[1]
```

**理由:**
1. ✅ **視認性が高い** - 乗算と明確に区別できる
2. ✅ **未使用** - 他の機能と競合しない
3. ✅ **VTL2との類似性** - 単一文字I/Oで使用（アクセス操作の連想）
4. ✅ **実装コストが低い** - レクサーとパーサーの小規模な変更のみ

### 第2候補: 現状維持 `*`

コードベースが既に実装済みであり、パーサーレベルでは正しく区別できるため、
視認性の懸念はあるものの、変更しないという選択肢も合理的。

**変更しない場合の対策:**
- ドキュメントで混乱しやすいパターンを明示
- コード例で明確な使い方を示す
- 複雑な式（`*=*+1`など）を避けるベストプラクティスを推奨

## 変更の影響範囲

### `*` → `$` に変更する場合

#### 1. レクサー (lexer.ts)
```typescript
// 変更不要（`$`は単一文字トークンとして追加済みの場合）
// または新規追加
if (char === '$') {
    tokens.push({ type: TokenType.DOLLAR, value: char, line: lineNumber, column: cursor });
    cursor++;
    continue;
}
```

#### 2. パーサー (workerInterpreter.ts)
```typescript
// parseExpression() の変更
if (token.type === TokenType.DOLLAR) {  // ASTERISK → DOLLAR
    return {
        type: 'PeekExpression',
        line: token.line,
        column: token.column,
    };
}

// parse() の変更
if (token.type === TokenType.DOLLAR) {  // ASTERISK → DOLLAR
    // POKE文の処理
}
```

#### 3. テストファイル (workerInterpreter.test.ts)
- 6つのPEEK/POKEテストのトークンを変更
- `TokenType.ASTERISK` → `TokenType.DOLLAR`

#### 4. ドキュメント
- `worker.md`: PEEK/POKEの構文例を更新
- `spec.md`: 必要に応じて更新

#### 5. 既存のスクリプト
- ユーザーが書いた既存のスクリプトは非互換（移行が必要）
- ただし、現時点では実装段階なので影響は最小限

## 結論

**推奨: `$` に変更する**

理由:
1. プロジェクトはまだ開発段階（テスト実装直後）
2. 視認性の向上はユーザー体験に大きく貢献
3. 変更コストは低い（影響範囲が限定的）
4. 将来の保守性が向上（混乱の軽減）

**実装手順:**
1. TDDサイクル 2B.6を巻き戻し（git revert）
2. レクサーに`$`トークンを追加（`DOLLAR`）
3. パーサーで`DOLLAR`を処理
4. テストを`$`に更新
5. ドキュメントを更新
6. コミット

**代替案: 現状維持**
変更コストを避けたい場合や、VTL2との記号の類似性を重視する場合は、
現状の`*`を維持し、ドキュメントでベストプラクティスを明示する方法も有効。

---

## 実装結果

**決定: `$`への変更を実施 (2025年10月16日)**

### 変更内容

1. **レクサー (lexer.ts)**
   - `TokenType.DOLLAR`を追加
   - `$`文字のトークン化処理を追加

2. **パーサー (workerInterpreter.ts)**
   - PEEK: `TokenType.ASTERISK` → `TokenType.DOLLAR`
   - POKE: `TokenType.ASTERISK` → `TokenType.DOLLAR`

3. **テスト (workerInterpreter.test.ts)**
   - 6個のPEEK/POKEテストを更新
   - すべてのテストが成功 (51/51)

4. **ドキュメント (worker.md)**
   - PEEK/POKEの構文例を`*` → `$`に更新
   - サンプルコードを更新

### 新しい構文

```workerscript
: PEEK - メモリ読み取り
A=$          : gridData[<計算されたインデックス>]を読み取り

: POKE - メモリ書き込み
$=A          : gridData[<計算されたインデックス>]に書き込み

: 複合例（視認性向上）
$=$+1        : PEEKして+1してPOKE（*=*+1より読みやすい）
```

### 利点の確認

✅ **視認性の大幅な向上**
- `$=$+1` vs `*=*+1` - 明らかに`$`の方が読みやすい
- 乗算演算子`*`との混同を完全に回避

✅ **VTL2との概念的な類似性**
- VTL2で`$`は単一文字I/Oに使用
- メモリアクセス操作という点で意味的に関連

✅ **実装の完了**
- すべてのテストが成功
- ドキュメントも更新完了
- 変更コストは予想通り低かった

### 今後の方針

この変更により、WorkerScriptの可読性とユーザー体験が向上しました。
`$`記号はPEEK/POKEの専用記号として確立され、`*`は乗算演算子としてのみ機能します。
