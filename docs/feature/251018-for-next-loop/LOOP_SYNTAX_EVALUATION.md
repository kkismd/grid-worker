# WorkerScript統一ループ構文の評価

## 🎯 提案されたループ構文

### FOR ループ
```
@=I=1,100,10    ← 変数=開始,終了,ステップ
  : 処理
#=@             ← ループ終了
```

### WHILE ループ  
```
@=X<100         ← 継続条件
  : 処理
#=@             ← ループ終了
```

## 📊 可読性評価

### ✅ **優秀な点**

#### 1. **統一されたパターン認識**
- 両方とも `@=` で開始、`#=@` で終了
- 一目でループ構造と認識可能
- ネストも視覚的に明確

#### 2. **意味の直観性**
```
@=I=1,100,10   ← "I に 1から100まで10刻みで割り当て"
@=X<100        ← "X<100 の間続ける"
```

#### 3. **コードの対称性**
```
@= ... ←─┐ 開始
  ...    │ 本体
#=@  ←─┘ 終了
```

### ⚠️ **課題点**

#### 1. **FOR文の複雑さ**
```
@=I=1,100,10
   ↑ ↑
   変数代入と範囲指定が重複
```

#### 2. **パース上の曖昧性**
```
@=I=1,100,10    ← = が2回出現
@=X<100         ← < 演算子との区別
```

## 🔧 パース解析

### FOR文のトークン解析
```
@=I=1,100,10
│││││││└─ 数値: 10
││││││└─ カンマ
│││││└─ 数値: 100  
││││└─ カンマ
│││└─ 数値: 1
││└─ 等号(代入)
│└─ 識別子: I
└─ @=パターン
```

**問題**: `@=` の後に `=` が続く構文的曖昧性

### WHILE文のトークン解析
```
@=X<100
│││└─ 数値: 100
││└─ 比較演算子: <
│└─ 識別子: X  
└─ @=パターン
```

**問題**: 比較演算子と通常の式の区別

## 💡 改善案

### 案1: 区切り記号の導入
```
FOR:   @=I,1,100,10     (= 除去、カンマ区切り)
WHILE: @=(X<100)        (括弧で条件明確化)
```

### 案2: キーワード併用
```
FOR:   @=FOR,I,1,100,10  (FOR キーワード)
WHILE: @=WHILE,X<100     (WHILE キーワード)
```

### 案3: 別記号使用
```
FOR:   @I=1,100,10      (変数直結)
WHILE: @?X<100          (? で条件明示)
```

## 🎯 総合評価

### 🟢 **可読性**: 8/10
- 統一パターンで優秀
- 視覚的構造が明確
- 直観的理解しやすい

### 🟡 **パース容易性**: 6/10
- FOR文の `=` 重複が複雑
- 文脈依存解析が必要
- 実装可能だが注意深い設計要

### 🟢 **言語一貫性**: 9/10  
- GOSUB/RETURNパターン完全適用
- 制御構造の統一性抜群
- 拡張性も優秀

## 🏆 推奨改良版

```
: FOR loop (区切り明確化)
@=I,1,100,10
  : 処理  
#=@

: WHILE loop (括弧で条件保護)
@=(X<100)
  : 処理
#=@
```

### ✅ **パーサー競合なし確認済み**

現在のインタープリターを分析した結果：

1. **主語判定**: `@=` で始まる文は専用パスで処理
2. **既存実装**: 括弧は `parsePrimaryExpression` で完全対応
3. **文脈分離**: 算術式 `(X+Y)` とループ文 `@=(X<100)` は明確に区別

```
算術式:    A = (X + Y) * 2     ← 式パーサーで処理
WHILE文:   @=(X<100)           ← ループパーサーで処理
```

**結論**: パーサー実装の複雑度増加なし、統一パターンの美しさを完全保持可能！

---

## ✅ 実装状況 (2025年10月18日)

### WHILE ループ実装完了

**構文**: `@=(condition) ~ #=@`

#### 実装内容
1. **AST定義** (`src/ast.ts`)
   - `WhileStatement` インターフェース追加
   - `condition: Expression` フィールドで条件式を保持

2. **パーサー** (`src/workerInterpreter.ts`)
   - `parseAtStatement` で `@=(` パターンを検出
   - 括弧内の条件式をパース
   - FOR構文 `@=I,1,100` と明確に区別

3. **実行エンジン** (`src/workerInterpreter.ts`)
   - `WhileStatement` 実行で条件評価とループ情報push
   - `NextStatement` (#=@) でWHILE/FOR両対応
   - ループスタックで `isWhile` フラグと `whileCondition` を保持
   - `findMatchingNext` でネストレベル管理（FOR/WHILE統一）

4. **テストカバレッジ** (`src/__tests__/workerInterpreter.test.ts`)
   - 基本WHILEループ ✅
   - 条件が最初から偽の場合のスキップ ✅
   - 条件変化（べき乗累積）✅
   - FOR+WHILEネストループ ✅
   - 複雑な条件式 (`A<B&A>0`) ✅
   - ゼロ回イテレーション ✅
   - WHILE+WHILEネストループ ✅

#### 全テスト結果
```
Tests:       186 passed, 186 total
```

### 統一構造の実現

| 構文 | 開始 | 終了 | 状態 |
|------|------|------|------|
| GOSUB | `!=^LABEL` | `#=!` | ✅ 実装済 |
| FOR | `@=I,1,100` | `#=@` | ✅ 実装済 |
| WHILE | `@=(condition)` | `#=@` | ✅ 実装済 |

**設計目標達成**: すべての制御構造が `#` と `@` 記号による統一パターンで実装完了！