# Grid共有メモリとアトミックプリミティブ設計

## 概要

Gridをワーカー同士の共有メモリとして使用する場合、スクリプト間通信の土台としてセマフォやキューのような同期機構を実装するために必要なアトミックプリミティブ操作を定義します。

## 設計方針

- **配列 `[addr]`**: ワーカー内部のローカルデータ領域（非共有）
- **Grid `` ` ``**: ワーカー間の共有メモリ領域（X, Y座標でアクセス）
- **アトミック性**: Grid操作は複数ワーカーから同時アクセスされても安全

## 必要なアトミックプリミティブ

### 1. テスト&セット操作（Test-And-Set）

排他制御の最も基本的なプリミティブ。

#### 構文
```workerscript
記号: &`
用途: セマフォのロック取得
構文: A=&`
説明: Grid[X,Y]の現在値を読み、非ゼロなら1をセット。元の値を返す。
      戻り値: 0=ロック取得成功、非0=既にロック中
```

#### 使用例
```workerscript
: スピンロック取得
^ACQUIRE_LOCK
    X=0 Y=0               : ロック変数の座標
^RETRY
    A=&`                  : テスト&セット
    ;=A=0 #=!             : 0なら取得成功、復帰
    #=^RETRY              : 非0なら再試行
```

**記号選択理由**: `&` は論理ANDで使用済みだが、`` &` ``（バッククォートとの組み合わせ）は文脈上明確に区別可能。

---

### 2. 比較&交換操作（Compare-And-Swap）

より高度なロックフリーアルゴリズムの基礎。

#### 構文
```workerscript
記号: { }
用途: 条件付きアトミック更新
構文: A={expected,newval}     : Grid[X,Y]がexpectedと一致すればnewvalをセット
説明: 期待値と実際の値が一致した場合のみ新値を書き込む
      戻り値: 1=成功、0=失敗（値が期待値と異なった）
```

#### 使用例
```workerscript
: CAS操作でカウンタをインクリメント
^INCREMENT_COUNTER
    X=5 Y=5               : カウンタ位置
^CAS_RETRY
    O=`                   : 現在値を読む
    N=O+1                 : 新値を計算
    A={O,N}               : CAS実行
    ;=A=0 #=^CAS_RETRY    : 失敗なら再試行
    #=!                   : 成功なら復帰
```

**記号選択理由**: `{` `}` は未使用（SYMBOL_RESOURCES.mdで🟢利用可能）。ペアで期待値・新値を表現。

---

### 3. アトミック加算（Fetch-And-Add）

カウンタ操作や参照カウントに使用。

#### 構文
```workerscript
記号: +`
用途: カウンタのアトミック更新
構文: A=+`                    : Grid[X,Y]に1を加算、加算前の値を返す
      A=+`=5                  : Grid[X,Y]に5を加算、加算前の値を返す
説明: 指定値をアトミックに加算し、加算前の値を返す
      省略時は+1として動作
```

#### 使用例
```workerscript
: リングバッファのtailポインタ更新
^ENQUEUE
    X=1 Y=0               : tail位置の座標
    T=+`                  : tailをアトミックにインクリメント
    T=T%100               : リングバッファサイズで剰余
    X=T Y=1               : データ格納位置
    `=D                   : データ書き込み
    #=!
```

**記号選択理由**: `+` と `` ` ``の組み合わせで「加算+Grid操作」を直感的に表現。

---

### 4. メモリバリア/フェンス

メモリ可視性を保証し、命令の並び替えを防止。

#### 構文
```workerscript
記号: | (単項演算子として)
用途: メモリ順序の保証
構文: |=0                     : 読み込みバリア（Load Fence）
      |=1                     : 書き込みバリア（Store Fence）
      |=2                     : 完全バリア（Full Fence）
説明: 0=他ワーカーの書き込みを可視化
      1=自分の書き込みを他ワーカーに可視化
      2=双方向の可視性を保証
```

#### 使用例
```workerscript
: プロデューサー（データ書き込み側）
^PRODUCE
    X=10 Y=10
    `=42                  : データ書き込み
    |=1                   : 書き込みバリア（他ワーカーから見えるよう保証）
    X=0 Y=0
    `=1                   : フラグセット（データ準備完了）
    #=!

: コンシューマー（データ読み込み側）
^CONSUME
    X=0 Y=0
^WAIT_DATA
    A=`                   : フラグチェック
    ;=A=0 #=^WAIT_DATA    : データ未準備なら待機
    |=0                   : 読み込みバリア（最新データを読む）
    X=10 Y=10
    D=`                   : データ読み込み（確実に42が読める）
    #=!
```

**記号選択理由**: `|` は論理ORで使用済みだが、単項演算子として使えば文脈で区別可能。パイプ記号は「流れ」を表し、メモリバリアの概念に合致。

---

### 5. 条件付き代入（Store-If-Zero）

効率的なロック取得のための簡易プリミティブ。

#### 構文
```workerscript
記号: \`
用途: ゼロチェック付き書き込み
構文: A=\`=value              : Grid[X,Y]が0ならvalueをセット
説明: Grid[X,Y]が0の場合のみvalueを書き込む
      戻り値: 1=成功（0だった）、0=失敗（非0だった）
```

#### 使用例
```workerscript
: 効率的なロック取得
^TRY_LOCK
    X=0 Y=0               : ロック変数
    A=\`=1                : 0なら1をセット
    ;=A=1 #=!             : 成功なら復帰
    A=0                   : 失敗コード
    #=!

: ロック解放
^UNLOCK
    X=0 Y=0
    `=0                   : ロッククリア
    #=!
```

**記号選択理由**: `\` は未使用（SYMBOL_RESOURCES.mdで拡張コマンド候補だが優先利用）。条件分岐を表す記号として適切。

---

## システム変数の追加

ワーカー識別とワーカー数の取得のための変数。

### ワーカーID

```workerscript
記号: _W
用途: 自ワーカーのID取得（0始まり）
例: I=_W                  : 自分のワーカーID
```

### ワーカー数

```workerscript
記号: _N
用途: 全ワーカー数の取得
例: N=_N                  : 総ワーカー数
```

**記号選択理由**: `_` はSYMBOL_RESOURCES.mdで未使用。システム変数のプリフィックスとして予約されている。

---

## 実装例1：セマフォ

```workerscript
: セマフォ初期化（値=1: バイナリセマフォ）
^INIT_SEMAPHORE
    X=0 Y=0
    `=1                   : 初期値セット
    #=!

: セマフォ取得（P操作）
^SEMAPHORE_P
    X=0 Y=0
^P_RETRY
    O=`                   : 現在値読み込み
    ;=O=0 #=^P_RETRY      : 0なら待機
    N=O-1                 : デクリメント
    A={O,N}               : CAS実行
    ;=A=0 #=^P_RETRY      : CAS失敗なら再試行
    #=!                   : 成功

: セマフォ解放（V操作）
^SEMAPHORE_V
    X=0 Y=0
    A=+`                  : アトミックインクリメント
    #=!
```

---

## 実装例2：リングバッファキュー

```workerscript
: キュー構造
: Grid[0,0] = head インデックス
: Grid[1,0] = tail インデックス
: Grid[0-99,1] = データ領域（100要素）

: キュー初期化
^INIT_QUEUE
    X=0 Y=0
    `=0                   : head = 0
    X=1 Y=0
    `=0                   : tail = 0
    #=!

: エンキュー（D=データ）
^ENQUEUE
    X=1 Y=0               : tail位置
    T=+`                  : tailをアトミックにインクリメント
    T=T%100               : リングバッファ（サイズ100）
    
    : 満杯チェック
    X=0 Y=0
    H=`                   : head読み込み
    F=T+1                 : 次のtail
    F=F%100
    ;=F=H A=0 #=!         : 満杯なら失敗（0を返す）
    
    : データ書き込み
    X=T Y=1
    `=D                   : データ格納
    |=1                   : 書き込みバリア
    A=1                   : 成功
    #=!

: デキュー（結果=A、空なら0）
^DEQUEUE
    X=0 Y=0
    H=`                   : head読み込み
    X=1 Y=0
    T=`                   : tail読み込み
    
    : 空チェック
    ;=H=T A=0 #=!         : 空なら0を返す
    
    : データ読み込み
    |=0                   : 読み込みバリア
    X=H Y=1
    A=`                   : データ取得
    
    : headインクリメント
    X=0 Y=0
    O=+`                  : headをアトミックにインクリメント
    #=!
```

---

## 実装例3：バリア同期

全ワーカーが特定地点で待ち合わせる同期機構。

```workerscript
: バリア初期化（N=ワーカー数）
^INIT_BARRIER
    X=0 Y=2
    `=0                   : 到着カウンタ
    X=1 Y=2
    `=N                   : 必要ワーカー数
    X=2 Y=2
    `=0                   : リリースフラグ
    #=!

: バリア待機
^BARRIER_WAIT
    : 到着をカウント
    X=0 Y=2
    C=+`                  : 到着カウンタをインクリメント
    C=C+1                 : +1（加算前の値が返るため）
    
    : 必要数チェック
    X=1 Y=2
    N=`
    ;=C<N #=^WAIT_RELEASE : 最後でなければ待機へ
    
    : 最後のワーカー：全員をリリース
    X=2 Y=2
    `=1                   : リリースフラグセット
    |=1                   : 書き込みバリア
    #=!

^WAIT_RELEASE
    X=2 Y=2
^SPIN_WAIT
    |=0                   : 読み込みバリア
    F=`                   : リリースフラグチェック
    ;=F=0 #=^SPIN_WAIT    : 0なら待機継続
    #=!                   : リリースされた
```

---

## 実装例4：読み書きロック（Read-Write Lock）

複数の読み込みは並行可能、書き込みは排他的。

```workerscript
: RWロック構造
: Grid[0,3] = 読み込みカウンタ（0以上=読み込み中の数）
: Grid[1,3] = 書き込みフラグ（0=フリー、1=書き込み中）

: 読み込みロック取得
^READ_LOCK
^R_RETRY
    X=1 Y=3
    W=`                   : 書き込みフラグチェック
    ;=W<>0 #=^R_RETRY     : 書き込み中なら待機
    
    X=0 Y=3
    R=+`                  : 読み込みカウンタをインクリメント
    
    : 再度書き込みフラグチェック（競合回避）
    X=1 Y=3
    W=`
    ;=W=0 #=!             : 書き込みなしなら成功
    
    : 書き込みが入っていたのでロールバック
    X=0 Y=3
    R=+`=-1               : カウンタをデクリメント
    #=^R_RETRY            : 再試行

: 読み込みロック解放
^READ_UNLOCK
    X=0 Y=3
    R=+`=-1               : カウンタをデクリメント
    #=!

: 書き込みロック取得
^WRITE_LOCK
^W_RETRY
    X=1 Y=3
    A=\`=1                : 書き込みフラグを立てる
    ;=A=0 #=^W_RETRY      : 失敗なら再試行
    
    : 読み込み中のワーカーを待つ
    X=0 Y=3
^W_WAIT_READERS
    |=0                   : 読み込みバリア
    R=`
    ;=R>0 #=^W_WAIT_READERS : 読み込み中なら待機
    #=!                   : 取得成功

: 書き込みロック解放
^WRITE_UNLOCK
    X=1 Y=3
    `=0                   : 書き込みフラグクリア
    |=1                   : 書き込みバリア
    #=!
```

---

## 記号使用の根拠

SYMBOL_RESOURCES.mdの状況に基づく記号選択：

| 記号 | 状態 | 選択理由 |
|------|------|----------|
| `` &` `` | 🟡 組み合わせ | `&`は論理ANDだが、バッククォートとの組み合わせで文脈上区別可能 |
| `{` `}` | 🟢 未使用 | 利用可能な波括弧ペア、CASの2引数表現に最適 |
| `` +` `` | 🟡 組み合わせ | `+`は加算だが、バッククォートとの組み合わせで「Grid上の加算」を表現 |
| `\|` 単項 | 🟡 再利用 | 論理ORだが単項演算子として使えば区別可能、パイプ記号は「流れ」を表現 |
| `` \` `` | 🟢 未使用 | バックスラッシュは拡張コマンド候補だが優先利用 |
| `_` | 🟢 未使用 | システム変数プリフィックスとして予約済み |

---

## メモリモデル

### 一貫性保証

- **アトミック操作**: `&``, `{}`、`+``, `\``は不可分に実行される
- **バリア命令**: `|=0/1/2`で順序付けを明示的に制御
- **デフォルト**: バリアなしの場合、弱い順序モデル（実装依存）

### 可視性ルール

1. 同一ワーカー内: プログラム順序で可視
2. 異なるワーカー間: バリア命令で保証
3. アトミック操作: 即座に可視（内部でバリア実行）

---

## パフォーマンス考慮

### スピンロックの改善

```workerscript
: 指数バックオフ付きスピンロック
^ACQUIRE_WITH_BACKOFF
    X=0 Y=0
    W=1                   : 待機時間
^BACKOFF_RETRY
    A=\`=1                : ロック試行
    ;=A=1 #=!             : 成功
    
    : バックオフ待機
    @=I,1,W
    #=@
    W=W*2                 : 待機時間を倍化
    ;=W>1000 W=1000       : 最大1000に制限
    #=^BACKOFF_RETRY
```

### ロックフリーアルゴリズム

CASを使ったロックフリースタック：

```workerscript
: スタックpush（D=データ）
^PUSH
    X=0 Y=4               : スタックトップポインタ
^PUSH_RETRY
    O=`                   : 現在のトップ読み込み
    
    : 新ノード作成（簡略化：固定領域使用）
    N=O+1                 : 新ノードインデックス
    X=N Y=4
    `=D                   : データ格納
    X=N Y=5
    `=O                   : nextポインタ
    
    : トップポインタ更新（CAS）
    X=0 Y=4
    A={O,N}               : CAS: top = N if top == O
    ;=A=0 #=^PUSH_RETRY   : 失敗なら再試行
    #=!

: スタックpop（結果=A、空なら0）
^POP
    X=0 Y=4
^POP_RETRY
    O=`                   : 現在のトップ
    ;=O=0 A=0 #=!         : 空なら0を返す
    
    : 次ノード読み込み
    X=O Y=5
    N=`                   : next読み込み
    
    : トップポインタ更新（CAS）
    X=0 Y=4
    S={O,N}               : CAS: top = next if top == O
    ;=S=0 #=^POP_RETRY    : 失敗なら再試行
    
    : データ取得
    X=O Y=4
    A=`                   : popされたデータ
    #=!
```

---

## 実装上の注意

### 1. ABA問題

CAS操作では、値がA→B→Aと変化した場合を検出できない。対策：

```workerscript
: バージョンカウンタ付きCAS
: Grid[X,Y] = データ
: Grid[X,Y+1] = バージョン

^VERSIONED_CAS
    X=5 Y=5
    O=`                   : 現在データ
    Y=6
    V=`                   : 現在バージョン
    
    : 新値・新バージョン計算
    N=O+1
    W=V+1
    
    : データとバージョンを両方チェック（簡略化例）
    Y=5
    A={O,N}
    ;=A=0 #=^FAIL
    Y=6
    B={V,W}
    ;=B=0 Y=5 `=O #=^FAIL  : バージョン不一致ならロールバック
    #=!

^FAIL
    A=0
    #=!
```

### 2. デッドロック回避

- ロック取得順序を統一
- タイムアウト機構の実装
- try_lock方式の採用

### 3. ライブロック回避

- 指数バックオフの使用
- ランダム待機時間の導入

```workerscript
: ランダムバックオフ
^RANDOM_BACKOFF
    W=~                   : ランダム値
    W=W%100               : 0-99の範囲
    W=W+10                : 最小10
    @=I,1,W
    #=@
    #=!
```

---

## まとめ

### 提案するプリミティブ一覧

| プリミティブ | 記号 | 主な用途 |
|-------------|------|---------|
| Test-And-Set | `` &` `` | スピンロック |
| Compare-And-Swap | `{}` | ロックフリーアルゴリズム |
| Fetch-And-Add | `` +` `` | カウンタ操作 |
| Memory Barrier | `\|=` | メモリ可視性保証 |
| Store-If-Zero | `` \` `` | 効率的ロック取得 |
| Worker ID | `_W` | ワーカー識別 |
| Worker Count | `_N` | 並行度取得 |

### 実現可能な同期機構

- ✅ スピンロック / ミューテックス
- ✅ セマフォ（カウンティング・バイナリ）
- ✅ リングバッファキュー
- ✅ バリア同期
- ✅ 読み書きロック
- ✅ ロックフリーデータ構造

これらのプリミティブにより、Gridを効果的な共有メモリとして活用し、複雑なワーカー間通信を実現できます。

---

*参照: worker.md, SYMBOL_RESOURCES.md*  
*最終更新: 2025年1月*
