# WorkerScript 言語仕様ドラフト (worker.md)

## 1. はじめに

WorkerScriptは、VTL言語の系譜に属し、グリッドワーカーアプリケーションのスクリプト実行環境として特化させた、シンプルなインタプリタ言語です。
gridDataの読み書きと、単純な整数演算、分岐やループの機能だけを持っています。

## 2. 基本概念

*   **実行モード:**
    *   **スクリプト実行:** テキストボックスに入力されたコードは、プログラムとして扱われ、明示的に実行されます。すべてのステートメントはプログラムの一部として解釈されます。
*   **行構造:**
    *   各行はステートメントで構成されます。
    *   行番号は使用せず、ラベルによるジャンプのみをサポートします。
    *   最大行長はRVTLに準じますが、ここでは特に制限しません。
*   **コメント:** `:` で始まる行はコメントとして扱われます。
*   **エラー処理:** 正しいプログラムとして解釈実行できない場合はエラーメッセージを出力して動作を停止します。エラーメッセージは、以下の主要なカテゴリに分類され、エラーの種類と原因を特定できる情報を提供します。
    *   **構文エラー:** プログラムの文法が不正な場合（例: 不明なコマンド、不正な式）。
    *   **実行時エラー:** プログラムの実行中に発生するエラー（例: ゼロ除算、範囲外メモリアクセス、GOSUBスタックオーバーフロー、FORループ変数の重複使用、FORループのステップ値が0）。
    *   **未定義ラベルエラー:** GOTOやGOSUBで存在しないラベルを参照した場合。
*   **インデント** ラベル定義文を除いてプログラムの行頭には任意の空白を置けますが、それは単に読み飛ばされます。スコープなどを定義するものではありません。

## 3. データ型

*   **数値:** −32768から32767までの16ビット符号あり整数。数値演算の結果がこの範囲を超える場合、結果は16ビットの範囲でラップアラウンドします。
*   **文字列:** ダブルクォーテーション (`"`) で囲まれたテキスト。文字列リテラルの最大長は255文字です。

## 4. 変数

*   **ユーザー変数:** 単一の大文字アルファベット (A-Z) が16ビット符号あり整数変数 (-32768 ~ 32767) として使用されます。RVTLと同様です。
*   **システム変数:** RVTLのシステム変数の一部はサポートされますが、入出力やファイル操作に関連するものは削除されます。プログラム開始時、以下のシステム変数は以下の初期値に設定されます。
    *   `#`: 次に実行されるステートメントのポインタ。プログラムの最初のステートメントを指します。この値はプログラムの実行中に常に更新されます。`#=<ラベル>` でジャンプ先を指定したり、`#=-1` でプログラムを停止したりするために使用されます。GOTOやGOSUBのリターンアドレスとして機能します。また、`#=-1` はプログラムの停止を意味します。
    *   `%`: 直前の割り算の余り。初期値は `0` です。
    *   `'`: ランダム数 (0-32767の符号なし範囲)。アクセスされるたびに新しいランダムな値が生成されます。
    *   `*`: メモリへのアクセスに使用される特殊システム変数。現在の `X` (行) と `Y` (列) の値を用いて、グリッドデータ (`gridData`) のインデックスを暗黙的に計算し、値の読み書きを行います。`X` と `Y` の初期値は `0` です。
## 5. 演算子

RVTLと同様の演算子をサポートします。

*   **算術演算:** `+`, `-`, `*`, `/`。除算において、除数が `0` の場合（ゼロ除算）、プログラムはエラーメッセージを出力して実行を停止します。
*   **比較演算:** `=`, `>`, `<`, `>=`, `<=`, `<>` (それぞれ真の場合は1、偽の場合は0を返します)。
*   **論理演算:** `&` (AND), `|` (OR), `!` (NOT)。
*   **演算順序:** 括弧 `()` を使用して優先順位を変更できます。括弧がない場合は、左から右へ評価されます。この仕様には注意が必要ですが、VTL系の言語に共通する特徴です。

## 6. コマンド (ステートメント)

RVTLのコマンドをベースに、WorkerScript独自の仕様に合わせて調整します。ステートメントは `<target>=<expression>` の形式、または複数の `<target>=<expression>` のシーケンスで構成されます。**複数のステートメントを同じ行に記述する場合、各ステートメントは1つ以上のスペースで区切られます。**

### 6.1. 代入

*   **構文:** `<変数>=<式>`
*   **例:** `I=100`

### 6.2. 出力

*   **命令:** `?`
*   **構文:** `?=<式>`
*   **説明:** `<expression>` が評価され、その結果がトランスクリプトエリアに出力されます。数値は10進数として、文字列はそのまま出力されます。**文字列の連結はサポートされません。**
*   **例:**
    *   `?=10` (数値 10 を出力)
    *   `?="Hello"` (文字列 "Hello" を出力)
    *   `A=5`
    *   `?="Value: " ?=A` (文字列 "Value: " と変数 A の値を出力)
*   **改行:** `/` は、それ自体が独立したステートメントとして機能し、改行を出力します。
    *   例:
        ```
        ?="First line"
        /
        ?="Second line"
        ```

### 6.3. 条件分岐 (IF)

*   **命令:** `;`
*   **構文:** `;=<条件> <ステートメント1> <ステートメント2> ...`
*   **説明:** 条件が真 (0でない値) の場合、指定されたステートメントが左から右へ順番に実行されます。
*   **例:** `;=A>100 ?=100 #=^END` (Aが100より大きい場合、`?=100` を実行し、次に `#=^END` を実行します)

### 6.4. 制御フロー (GOTO, GOSUB, RETURN)

*   **GOTO:** システム変数 `#` を使用してラベルにジャンプします。
    *   **構文:** `#=<ラベル>`
    *   **例:** `#=^START_LOOP`
*   **GOSUB:** システム変数 `!` を使用してサブルーチンにジャンプします。`GOSUB` のネストの最大深度は256回です。これを超えるネストが発生した場合、プログラムはエラーメッセージを出力して実行を停止します。
    *   **構文:** `!=<ラベル>`
    *   **例:** `!=^MY_SUB`
*   **RETURN:** システム変数 `]` を使用してサブルーチンから戻ります。
    *   **構文:** `]`
    *   **例:** `]`

### 6.5. FORループ

*   **構文:** `<loop_variable>=<start_value>,<end_value>[,<step_value>]`
*   **説明:** FORループを初期化します。`<loop_variable>` は `<start_value>` から `<end_value>` まで反復されます。`<step_value>` が省略された場合、デフォルトは 1 です。`step_value` に `0` を指定した場合、実行時エラーとしてプログラムは停止します。この代入パターンは、インタプリタによってFORループの開始として認識されます。FORループはネストして使用でき、ネストの最大深度は256回です。これを超えるネストが発生した場合、プログラムはエラーメッセージを出力して実行を停止します。ネストした内部で同じ変数をループ変数として使おうとすると、実行時エラーでプログラムは停止します。**また、対応する `FOR` ステートメントが存在しない `NEXT` ステートメント、または `NEXT` ステートメントの `<loop_variable>` が現在の `FOR` ループのループ変数と一致しない場合も、実行時エラーとしてプログラムは停止します。**
*   **例:** `I=1,100` (FOR I=1 TO 100 STEP 1 に相当)
*   **例:** `J=10,1,-1` (FOR J=10 TO 1 STEP -1 に相当)

### 6.6. NEXT

*   **命令:** `@`
*   **構文:** `@=<loop_variable>`
*   **説明:** ループ変数をインクリメントし、ループ条件をチェックします。ループが継続する場合、対応する `FOR` ステートメントの次のステートメントにジャンプします。ループが終了する場合、`NEXT` ステートメントの次の実行可能なステートメントに進みます。ステップ値は `FOR` の初期化時に指定されたものが使用されます。
*   **例:** `@=I` (NEXT I に相当)

### 6.7. プログラム停止

*   **命令:** `#` (システム変数)
*   **構文:** `#=-1`
*   **説明:** プログラムの実行を停止します。
*   **例:** `#=-1`

### 6.8. メモリ操作

システム変数 `*` を用いた `gridData` へのアクセスにおいて、現在の `X` (行) と `Y` (列) の値はそれぞれ `0` から `99` の範囲にラップアラウンドされて使用されます。グリッド幅は100と仮定され、インデックスは `(X % 100) * 100 + (Y % 100)` で計算されます。

*   **PEEK:** システム変数 `$` を使用して、計算されたグリッドデータ (`gridData`) のインデックスにある値を参照し、変数に代入します。
    *   **構文:** `<variable> = $`
    *   **例:** `A = $`
*   **POKE:** システム変数 `$` を使用して、計算されたグリッドデータ (`gridData`) のインデックスに値を書き込みます。
    *   **構文:** `$ = <value_expression>`
    *   **例:** `$ = A`

### 6.9. コメント

*   **構文:** `:` で始まる行全体がコメントとして扱われます。
*   **例:** `: This is a comment`

## 7. ラベル定義

ラベルは、プログラム内の特定の場所を示すために使用されます。
*   ラベルは `^` で始まり、その後に英数字とアンダースコア (`_`) で構成される識別子が続きます。
*   ラベルは行の先頭に記述され、その後に改行が続きます。
*   **ラベル名はプログラム内で一意である必要があります。同じ名前のラベルが複数定義された場合、プログラムは構文エラーとして実行を停止します。**
*   例:
    ```
    ^MY_LABEL
        ?="This is my label." /
    ```

## 8. 入出力とファイル操作の制限

*   **文字入出力:** サポートされません。
*   **ファイル入出力:** サポートされません。
*   **トランスクリプト出力:** `?=` コマンドのみが使用でき、文字列と `/` による改行のみを出力します。

## 9. 例

```workerscript
: WorkerScript Example Program

?="--- WorkerScript Interpreter ---" /
?="Initializing..." /

: SUB-ROUTINE CALL
!=GREETING_ROUTINE

: Define some variables
A=10
B=20

: Perform calculation
C=A+B
?="Sum of A and B: " /
?=C /

: Conditional jump
;=C>25 #=^GREATER_THAN_25

?="C is not greater than 25." /
#=^END_PROGRAM

^GREATER_THAN_25
    ?="C is greater than 25." /
    : Example of PEEK/POKE using grid coordinates X and Y
    X=5 Y=10
    A = $ : Read value from grid cell (X, Y)
    ?="Value from grid cell (" + X + "," + Y + "): " /
    ?=A /
    $ = C : Write value C to grid cell (X, Y)

^GREETING_ROUTINE
    ?="Hello, world!" /
    ]

^END_PROGRAM
    ?="Program finished." /
    #=-1 : STOP command

: FOR loop example
^FOR_LOOP_START
    I=1,5 : Initializes FOR loop for I from 1 to 5 (STEP 1 is default)
    ?="Loop iteration: " /
    ?=I /
    @=I : NEXT I (STEP is handled by FOR initialization)
```

